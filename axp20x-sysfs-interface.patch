diff --git a/drivers/mfd/axp20x.c b/drivers/mfd/axp20x.c
index 9842199..9f9aaff 100644
--- a/drivers/mfd/axp20x.c
+++ b/drivers/mfd/axp20x.c
@@ -26,6 +26,7 @@
 #include <linux/of_device.h>
 #include <linux/of_irq.h>
 #include <linux/acpi.h>
+#include <linux/delay.h>
 
 #define AXP20X_OFF	0x80
 
@@ -606,6 +607,261 @@ static void axp20x_power_off(void)
 		     AXP20X_OFF);
 }
 
+static int axp20x_averaging_helper(struct regmap *reg_map, unsigned int reg_h,
+	unsigned int width)
+{
+	long acc = 0;
+	int ret = 0, i;
+
+	for (i = 0; i < 3; i++)
+	{
+		ret = axp20x_read_variable_width(reg_map, reg_h, width);
+		if (ret < 0)
+			return ret;
+		acc += ret;
+		// For 100Hz sampling frequency
+		msleep(20);
+	}
+	acc /= 3;
+	ret = (int)acc;
+
+	return ret;
+}
+
+/*
+	sysfs read hendlers
+*/
+
+static ssize_t axp20x_read_volatile(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct axp20x_dev *axp = dev_get_drvdata(dev);
+	int val, ret, scale;
+	unsigned int reg, width = 12, offset = 0;
+	bool convert_to_micro = true;
+
+	if (axp == NULL)
+	{
+		dev_err(dev, "AXP sysfs: device pointer is NULL\n");
+		return -EINVAL;
+	}
+
+	if (strcmp(attr->attr.name, "acin_voltage") == 0)
+	{
+		reg = AXP20X_ACIN_V_ADC_H;
+		scale = 1700;
+	}
+	else if (strcmp(attr->attr.name, "acin_current") == 0)
+	{
+		reg = AXP20X_ACIN_I_ADC_H;
+		scale = 625;
+	}
+	else if (strcmp(attr->attr.name, "vbus_voltage") == 0)
+	{
+		reg = AXP20X_VBUS_V_ADC_H;
+		scale = 1700;
+	}
+	else if (strcmp(attr->attr.name, "vbus_current") == 0)
+	{
+		reg = AXP20X_VBUS_I_ADC_H;
+		scale = 375;
+	}
+	else if (strcmp(attr->attr.name, "internal_temp") == 0)
+	{
+		reg = AXP20X_TEMP_ADC_H;
+		scale = 1000;
+		offset = 1447;
+		convert_to_micro = false;
+	}
+	else if (strcmp(attr->attr.name, "battery_ts_voltage") == 0)
+	{
+		reg = AXP20X_TS_IN_H;
+		scale = 800;
+	}
+	else if (strcmp(attr->attr.name, "battery_voltage") == 0)
+	{
+		reg = AXP20X_BATT_V_H;
+		scale = 1100;
+	}
+	else if (strcmp(attr->attr.name, "battery_charge_current") == 0)
+	{
+		reg = AXP20X_BATT_CHRG_I_H;
+		scale = 500;
+	}
+	else if (strcmp(attr->attr.name, "battery_discharge_current") == 0)
+	{
+		reg = AXP20X_BATT_DISCHRG_I_H;
+		scale = 500;
+		width = 13;
+	}
+	else if (strcmp(attr->attr.name, "ipsout_voltage") == 0)
+	{
+		reg = AXP20X_IPSOUT_V_HIGH_H;
+		scale = 1400;
+	}
+	else
+		return -EINVAL;
+
+	ret = axp20x_averaging_helper(axp->regmap, reg, width);
+
+	if (ret < 0)
+		return ret;
+
+	val = ret * scale / 1000 - offset;
+	if (convert_to_micro)
+		val *= 1000;
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t axp20x_read_status(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct axp20x_dev *axp = dev_get_drvdata(dev);
+	int val, ret;
+	unsigned int res, reg, bit;
+
+	if (axp == NULL)
+	{
+		dev_err(dev, "AXP sysfs: device pointer is NULL\n");
+		return -EINVAL;
+	}
+
+	if (strcmp(attr->attr.name, "status_acin_connected") == 0)
+	{
+		reg = AXP20X_PWR_INPUT_STATUS;
+		bit = 7;
+	}
+	else if (strcmp(attr->attr.name, "status_acin_used") == 0)
+	{
+		reg = AXP20X_PWR_INPUT_STATUS;
+		bit = 6;
+	}
+	else if (strcmp(attr->attr.name, "status_vbus_connected") == 0)
+	{
+		reg = AXP20X_PWR_INPUT_STATUS;
+		bit = 5;
+	}
+	else if (strcmp(attr->attr.name, "status_vbus_used") == 0)
+	{
+		reg = AXP20X_PWR_INPUT_STATUS;
+		bit = 4;
+	}
+	else if (strcmp(attr->attr.name, "status_battery_charge_in_progress") == 0)
+	{
+		reg = AXP20X_PWR_OP_MODE;
+		bit = 6;
+	}
+	else if (strcmp(attr->attr.name, "status_battery_connected") == 0)
+	{
+		reg = AXP20X_PWR_OP_MODE;
+		bit = 5;
+	}
+	else if (strcmp(attr->attr.name, "status_cold_boot") == 0)
+	{
+		reg = AXP20X_PWR_INPUT_STATUS;
+		bit = 0;
+	}
+	else
+		return -EINVAL;
+
+	ret = regmap_read(axp->regmap, reg, &res);
+	if (ret < 0)
+		return ret;
+
+	val = (res & (1 << bit)) == (1 << bit) ? 1 : 0;
+
+	return sprintf(buf, "%d\n", val);
+}
+
+/*
+	sysfs attributes
+*/
+static DEVICE_ATTR(acin_voltage, S_IRUGO, axp20x_read_volatile, NULL);
+static DEVICE_ATTR(acin_current, S_IRUGO, axp20x_read_volatile, NULL);
+static DEVICE_ATTR(vbus_voltage, S_IRUGO, axp20x_read_volatile, NULL);
+static DEVICE_ATTR(vbus_current, S_IRUGO, axp20x_read_volatile, NULL);
+static DEVICE_ATTR(internal_temp, S_IRUGO, axp20x_read_volatile, NULL);
+static DEVICE_ATTR(battery_ts_voltage, S_IRUGO, axp20x_read_volatile, NULL);
+static DEVICE_ATTR(battery_voltage, S_IRUGO, axp20x_read_volatile, NULL);
+static DEVICE_ATTR(battery_charge_current, S_IRUGO, axp20x_read_volatile, NULL);
+static DEVICE_ATTR(battery_discharge_current, S_IRUGO, axp20x_read_volatile, NULL);
+static DEVICE_ATTR(ipsout_voltage, S_IRUGO, axp20x_read_volatile, NULL);
+
+static DEVICE_ATTR(status_acin_connected, S_IRUGO, axp20x_read_status, NULL);
+static DEVICE_ATTR(status_acin_used, S_IRUGO, axp20x_read_status, NULL);
+static DEVICE_ATTR(status_vbus_connected, S_IRUGO, axp20x_read_status, NULL);
+static DEVICE_ATTR(status_vbus_used, S_IRUGO, axp20x_read_status, NULL);
+static DEVICE_ATTR(status_battery_charge_in_progress, S_IRUGO, axp20x_read_status, NULL);
+static DEVICE_ATTR(status_battery_connected, S_IRUGO, axp20x_read_status, NULL);
+static DEVICE_ATTR(status_cold_boot, S_IRUGO, axp20x_read_status, NULL);
+
+
+static struct attribute *axp20x_sysfs_attributes[] = {
+
+	&dev_attr_acin_voltage.attr,
+	&dev_attr_acin_current.attr,
+	&dev_attr_vbus_voltage.attr,
+	&dev_attr_vbus_current.attr,
+	&dev_attr_internal_temp.attr,
+	&dev_attr_battery_ts_voltage.attr,
+	&dev_attr_battery_voltage.attr,
+	&dev_attr_battery_charge_current.attr,
+	&dev_attr_battery_discharge_current.attr,
+	&dev_attr_ipsout_voltage.attr,
+
+	&dev_attr_status_acin_connected.attr,
+	&dev_attr_status_acin_used.attr,
+	&dev_attr_status_vbus_connected.attr,
+	&dev_attr_status_vbus_used.attr,
+	&dev_attr_status_battery_charge_in_progress.attr,
+	&dev_attr_status_battery_connected.attr,
+	&dev_attr_status_cold_boot.attr,
+
+	NULL,
+};
+
+static const struct attribute_group axp20x_sysfs_attr_group = {
+	.attrs = axp20x_sysfs_attributes,
+};
+
+/*
+	sysfs register/inregister functions
+*/
+
+static int axp20x_sysfs_init(struct axp20x_dev *axp)
+{
+	int ret;
+	unsigned int res;
+	// Enable all ADC channels in first register
+	ret = regmap_write(axp->regmap, AXP20X_ADC_EN1, 0xFF);
+	if (ret != 0)
+		dev_warn(axp->dev, "Unable to enable ADC");
+
+	// Set ADC sampling frequency to 100Hz (default is 25)
+	// Always measure battery temperature (default: only when charging)
+	ret = regmap_update_bits(axp->regmap, AXP20X_ADC_RATE, 0xC3, 0x83);
+	if (ret != 0)
+		dev_warn(axp->dev, "Unable to set ADC frequency and TS current output");
+
+	ret = regmap_read(axp->regmap, AXP20X_OFF_CTRL, &res);
+	if (ret == 0 && (res & (1 << 6)) != (1 << 6))
+		dev_warn(axp->dev, "Battery detection is disabled");
+
+	ret = sysfs_create_group(&axp->dev->kobj, &axp20x_sysfs_attr_group);
+	if (ret != 0)
+		dev_warn(axp->dev, "Unable to register sysfs group");
+
+	ret = sysfs_create_link_nowarn(power_kobj, &axp->dev->kobj, "axp_pmu");
+	if (ret != 0)
+		dev_warn(axp->dev, "Unable to create sysfs symlink");
+	return ret;
+}
+
+static void axp20x_sysfs_exit(struct axp20x_dev *axp)
+{
+	sysfs_delete_link(power_kobj, &axp->dev->kobj, "axp_pmu");
+	sysfs_remove_group(&axp->dev->kobj, &axp20x_sysfs_attr_group);
+}
+
 static int axp20x_match_device(struct axp20x_dev *axp20x, struct device *dev)
 {
 	const struct acpi_device_id *acpi_id;
@@ -711,6 +967,10 @@ static int axp20x_i2c_probe(struct i2c_client *i2c,
 		pm_power_off = axp20x_power_off;
 	}
 
+	if (axp20x->variant == AXP209_ID) {
+		axp20x_sysfs_init(axp20x);
+	}
+
 	dev_info(&i2c->dev, "AXP20X driver loaded\n");
 
 	return 0;
@@ -720,6 +980,10 @@ static int axp20x_i2c_remove(struct i2c_client *i2c)
 {
 	struct axp20x_dev *axp20x = i2c_get_clientdata(i2c);
 
+	if (axp20x->variant == AXP209_ID) {
+		axp20x_sysfs_exit(axp20x);
+	}
+
 	if (axp20x == axp20x_pm_power_off) {
 		axp20x_pm_power_off = NULL;
 		pm_power_off = NULL;
