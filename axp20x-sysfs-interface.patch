diff --git a/drivers/mfd/axp20x.c b/drivers/mfd/axp20x.c
index 9842199..913550c 100644
--- a/drivers/mfd/axp20x.c
+++ b/drivers/mfd/axp20x.c
@@ -26,6 +26,7 @@
 #include <linux/of_device.h>
 #include <linux/of_irq.h>
 #include <linux/acpi.h>
+#include <linux/delay.h>
 
 #define AXP20X_OFF	0x80
 
@@ -606,6 +607,184 @@ static void axp20x_power_off(void)
 		     AXP20X_OFF);
 }
 
+static int axp20x_averaging_helper(struct axp20x_dev *axp, unsigned int reg_h,
+	unsigned int reg_l, unsigned int *val, bool reg_l_5bit)
+{
+	unsigned int rval_low = 0, rval_high = 0, i;
+	long acc = 0;
+	int ret = 0;
+
+	for (i = 0; i < 3; i++)
+	{
+		ret |= regmap_read(axp->regmap, reg_h, &rval_high);
+		ret |= regmap_read(axp->regmap, reg_l, &rval_low);
+		acc += (int)((rval_high << (reg_l_5bit ? 5 : 4)) | (rval_low & (reg_l_5bit ? 0x001F : 0x000F)));
+		// For 100Hz sampling frequency
+		msleep(20);
+	}
+	acc /= 3;
+	*val = (int)acc;
+
+	return ret;
+}
+
+/*
+ * axp_show_property() - get sysfs property for AXP209
+ * @dev:       pointer to the device structure
+ * @attr:      pointer to the device_attribute structure
+ * @val:       pointer to the output buffer
+ *
+ * This function gets called when an application tries to read sysfs property
+ * Returns error code in case of failure else 0 (on success)
+ */
+static ssize_t axp20x_show_property(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct axp20x_dev *axp = dev_get_drvdata(dev);
+	unsigned int rval_low = 0, rval_high = 0;
+	int val, ret;
+
+	if (axp == NULL)
+	{
+		dev_err(dev, "AXP sysfs: device pointer is NULL\n");
+		return -EINVAL;
+	}
+
+	if (strcmp(attr->attr.name, "acin_voltage") == 0)
+	{
+		ret = axp20x_averaging_helper(axp, AXP20X_ACIN_V_ADC_H, AXP20X_ACIN_V_ADC_L, &val, false);
+		//ret = regmap_read(axp->regmap, AXP20X_ACIN_V_ADC_H, &rval_high);
+		//ret |= regmap_read(axp->regmap, AXP20X_ACIN_V_ADC_L, &rval_low);
+		//val = (int)((rval_high << 4) | (rval_low & 0x0F)) * 1700 / 1000;
+		val = val * 1700 / 1000;
+	}
+	else if (strcmp(attr->attr.name, "acin_current") == 0)
+	{
+		ret = axp20x_averaging_helper(axp, AXP20X_ACIN_I_ADC_H, AXP20X_ACIN_I_ADC_L, &val, false);
+		//ret = regmap_read(axp->regmap, AXP20X_ACIN_I_ADC_H, &rval_high);
+		//ret |= regmap_read(axp->regmap, AXP20X_ACIN_I_ADC_L, &rval_low);
+		//val = (int)((rval_high << 4) | (rval_low & 0x0F)) * 625 / 1000;
+		val = val * 625 / 1000;
+	}
+	else if (strcmp(attr->attr.name, "vbus_voltage") == 0)
+	{
+		ret = regmap_read(axp->regmap, AXP20X_VBUS_V_ADC_H, &rval_high);
+		ret |= regmap_read(axp->regmap, AXP20X_VBUS_V_ADC_L, &rval_low);
+		val = (int)((rval_high << 4) | (rval_low & 0x0F)) * 1700 / 1000;
+	}
+	else if (strcmp(attr->attr.name, "vbus_current") == 0)
+	{
+		ret = regmap_read(axp->regmap, AXP20X_VBUS_I_ADC_H, &rval_high);
+		ret |= regmap_read(axp->regmap, AXP20X_VBUS_I_ADC_L, &rval_low);
+		val = (int)((rval_high << 4) | (rval_low & 0x0F)) * 375 / 1000;
+	}
+	else if (strcmp(attr->attr.name, "internal_temp") == 0)
+	{
+		ret = regmap_read(axp->regmap, AXP20X_TEMP_ADC_H, &rval_high);
+		ret |= regmap_read(axp->regmap, AXP20X_TEMP_ADC_L, &rval_low);
+		val = (int)((rval_high << 4) | (rval_low & 0x0F)) - 1447;
+	}
+	else if (strcmp(attr->attr.name, "battery_ts_voltage") == 0)
+	{
+		ret = regmap_read(axp->regmap, AXP20X_TS_IN_H, &rval_high);
+		ret |= regmap_read(axp->regmap, AXP20X_TS_IN_L, &rval_low);
+		val = (int)((rval_high << 4) | (rval_low & 0x0F)) * 800 / 1000;
+	}
+	else if (strcmp(attr->attr.name, "battery_voltage") == 0)
+	{
+		ret = regmap_read(axp->regmap, AXP20X_BATT_V_H, &rval_high);
+		ret |= regmap_read(axp->regmap, AXP20X_BATT_V_L, &rval_low);
+		val = (int)((rval_high << 4) | (rval_low & 0x0F)) * 1100 / 1000;
+	}
+	else if (strcmp(attr->attr.name, "battery_charge_current") == 0)
+	{
+		ret = regmap_read(axp->regmap, AXP20X_ACIN_V_ADC_H, &rval_high);
+		ret |= regmap_read(axp->regmap, AXP20X_ACIN_V_ADC_L, &rval_low);
+		val = (int)((rval_high << 4) | (rval_low & 0x0F)) * 500 / 1000;
+	}
+	else if (strcmp(attr->attr.name, "battery_discharge_current") == 0)
+	{
+		ret = regmap_read(axp->regmap, AXP20X_ACIN_V_ADC_H, &rval_high);
+		ret |= regmap_read(axp->regmap, AXP20X_ACIN_V_ADC_L, &rval_low);
+		val = (int)((rval_high << 5) | (rval_low & 0x1F)) * 500 / 1000;
+	}
+	else if (strcmp(attr->attr.name, "ipsout_voltage") == 0)
+	{
+		ret = regmap_read(axp->regmap, AXP20X_IPSOUT_V_HIGH_H, &rval_high);
+		ret |= regmap_read(axp->regmap, AXP20X_IPSOUT_V_HIGH_L, &rval_low);
+		val = (int)((rval_high << 4) | (rval_low & 0x0F)) * 1400 / 1000;
+	}
+	else
+		return -EINVAL;
+
+	if (ret != 0)
+		return ret;
+	return sprintf(buf, "%d\n", val);
+}
+
+/*
+	sysfs attributes
+*/
+static DEVICE_ATTR(acin_voltage, S_IRUGO, axp20x_show_property, NULL);
+static DEVICE_ATTR(acin_current, S_IRUGO, axp20x_show_property, NULL);
+static DEVICE_ATTR(vbus_voltage, S_IRUGO, axp20x_show_property, NULL);
+static DEVICE_ATTR(vbus_current, S_IRUGO, axp20x_show_property, NULL);
+static DEVICE_ATTR(internal_temp, S_IRUGO, axp20x_show_property, NULL);
+static DEVICE_ATTR(battery_ts_voltage, S_IRUGO, axp20x_show_property, NULL);
+static DEVICE_ATTR(battery_voltage, S_IRUGO, axp20x_show_property, NULL);
+static DEVICE_ATTR(battery_charge_current, S_IRUGO, axp20x_show_property, NULL);
+static DEVICE_ATTR(battery_discharge_current, S_IRUGO, axp20x_show_property, NULL);
+static DEVICE_ATTR(ipsout_voltage, S_IRUGO, axp20x_show_property, NULL);
+
+static struct attribute *axp20x_sysfs_attributes[] = {
+
+	&dev_attr_acin_voltage.attr,
+	&dev_attr_acin_current.attr,
+
+	&dev_attr_vbus_voltage.attr,
+	&dev_attr_vbus_current.attr,
+
+	&dev_attr_internal_temp.attr,
+
+	&dev_attr_battery_ts_voltage.attr,
+	&dev_attr_battery_voltage.attr,
+	&dev_attr_battery_charge_current.attr,
+	&dev_attr_battery_discharge_current.attr,
+
+	&dev_attr_ipsout_voltage.attr,
+
+	NULL,
+};
+
+static const struct attribute_group axp20x_sysfs_attr_group = {
+	.attrs = axp20x_sysfs_attributes,
+};
+
+/*
+	sysfs functions
+*/
+
+static int axp20x_sysfs_init(struct axp20x_dev *axp)
+{
+	int ret;
+	// Enable all ADC channels in first register
+	ret = regmap_write(axp->regmap, AXP20X_ADC_EN1, 0xFF);
+	if (ret != 0)
+		dev_warn(axp->dev, "Unable to enable ADC");
+
+	// Set ADC sampling frequency to 100Hz (default is 25)
+	ret = regmap_update_bits(axp->regmap, AXP20X_ADC_EN2, 0xC0, 0x80);
+	if (ret != 0)
+		dev_warn(axp->dev, "Unable to set ADC frequency");
+
+	return sysfs_create_group(&axp->dev->kobj,
+			&axp20x_sysfs_attr_group);
+}
+
+static void axp20x_sysfs_exit(struct axp20x_dev *axp)
+{
+	sysfs_remove_group(&axp->dev->kobj, &axp20x_sysfs_attr_group);
+}
+
 static int axp20x_match_device(struct axp20x_dev *axp20x, struct device *dev)
 {
 	const struct acpi_device_id *acpi_id;
@@ -711,6 +890,10 @@ static int axp20x_i2c_probe(struct i2c_client *i2c,
 		pm_power_off = axp20x_power_off;
 	}
 
+	if (axp20x->variant == AXP209_ID) {
+		axp20x_sysfs_init(axp20x);
+	}
+
 	dev_info(&i2c->dev, "AXP20X driver loaded\n");
 
 	return 0;
@@ -720,6 +903,10 @@ static int axp20x_i2c_remove(struct i2c_client *i2c)
 {
 	struct axp20x_dev *axp20x = i2c_get_clientdata(i2c);
 
+	if (axp20x->variant == AXP209_ID) {
+		axp20x_sysfs_exit(axp20x);
+	}
+
 	if (axp20x == axp20x_pm_power_off) {
 		axp20x_pm_power_off = NULL;
 		pm_power_off = NULL;
